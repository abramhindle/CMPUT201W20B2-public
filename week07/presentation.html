<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-02-27 Thu 11:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CMPUT201W20B2 Week 7</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Abram Hindle" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CMPUT201W20B2 Week 7</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org185054c">1. Week7</a>
<ul>
<li><a href="#org8e7fb06">1.1. Copyright Statement</a>
<ul>
<li><a href="#org66bff0a">1.1.1. License</a></li>
<li><a href="#org17a4fdf">1.1.2. Hazel Code is licensed under AGPL3.0+</a></li>
</ul>
</li>
<li><a href="#org3efaf2b">1.2. Init ORG-MODE</a></li>
<li><a href="#org834f4ea">1.3. Org Template</a></li>
<li><a href="#orgdd09923">1.4. Remember how to compile?</a></li>
<li><a href="#org5139fd7">1.5. Enums!</a>
<ul>
<li><a href="#org0276f77">1.5.1. Enum Example</a></li>
<li><a href="#orgd818c9b">1.5.2. enum<sub>typedef.c</sub></a></li>
<li><a href="#org20adc4b">1.5.3. EnumStart</a></li>
<li><a href="#org4a7ae7d">1.5.4. Enumassign</a></li>
<li><a href="#org60b11b3">1.5.5. Enum<sub>loop</sub><sub>trick.c</sub></a></li>
<li><a href="#orgc14056f">1.5.6. Enum Int</a></li>
<li><a href="#org7b88e2a">1.5.7. Another motivating ENUM Example</a></li>
</ul>
</li>
<li><a href="#org2d4e8f8">1.6. Unions</a>
<ul>
<li><a href="#orgcc8debe">1.6.1. Structs versus Unions</a></li>
<li><a href="#org5455fdf">1.6.2. Union considerations</a></li>
<li><a href="#orgf72751f">1.6.3. Type Punning</a></li>
<li><a href="#orgab047e8">1.6.4. Unions with type tags</a></li>
</ul>
</li>
<li><a href="#org1070be1">1.7. Malloc! The Heap!</a>
<ul>
<li><a href="#org8ad14c4">1.7.1. On my computer</a></li>
<li><a href="#org46291f3">1.7.2. Malloc</a></li>
<li><a href="#orgbe3b70c">1.7.3. Malloc2</a></li>
<li><a href="#org395c784">1.7.4. Calloc</a></li>
<li><a href="#orgf631b7a">1.7.5. strdup</a></li>
<li><a href="#org0c20255">1.7.6. free</a></li>
<li><a href="#org8ba35ef">1.7.7. realloc!</a></li>
<li><a href="#org4f10e94">1.7.8. Malloc and structs</a></li>
<li><a href="#org4416697">1.7.9. Malloc 2D arrays</a></li>
<li><a href="#org4c81331">1.7.10. Malloc Array of Array versus 2D</a></li>
<li><a href="#org952a85a">1.7.11. Malloc array of arrays structs?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org185054c" class="outline-2">
<h2 id="org185054c"><span class="section-number-2">1</span> Week7</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org8e7fb06" class="outline-3">
<h3 id="org8e7fb06"><span class="section-number-3">1.1</span> Copyright Statement</h3>
<div class="outline-text-3" id="text-1-1">
<p>
If you are in CMPUT201 at UAlberta this code is released in the public
domain to you.
</p>

<p>
Otherwise it is (c) 2020 Abram Hindle, Hazel Campbell AGPL3.0+
</p>
</div>

<div id="outline-container-org66bff0a" class="outline-4">
<h4 id="org66bff0a"><span class="section-number-4">1.1.1</span> License</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Week 3 notes
Copyright (C) 2020 Abram Hindle, Hazel Campbell
</p>

<p>
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.
</p>

<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.
</p>

<p>
You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
</p>
</div>
</div>


<div id="outline-container-org17a4fdf" class="outline-4">
<h4 id="org17a4fdf"><span class="section-number-4">1.1.2</span> Hazel Code is licensed under AGPL3.0+</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Hazel's code is also found here
<a href="https://github.com/hazelybell/examples/tree/C-2020-01">https://github.com/hazelybell/examples/tree/C-2020-01</a>
</p>

<p>
Hazel code is licensed: The example code is licensed under the AGPL3+
license, unless otherwise noted.
</p>
</div>
</div>
</div>

<div id="outline-container-org3efaf2b" class="outline-3">
<h3 id="org3efaf2b"><span class="section-number-3">1.2</span> Init ORG-MODE</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">I need this for org-mode to work well</span>

<span style="color: #b22222;">;</span><span style="color: #b22222;">(require 'ob-sh)</span>
(<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">ob-shell</span>)
<span style="color: #b22222;">; </span><span style="color: #b22222;">(org-babel-do-load-languages 'org-babel-load-languages '((sh . t)))</span>
(org-babel-do-load-languages 'org-babel-load-languages '((shell . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
(<span style="color: #a020f0;">setq</span> org-src-fontify-natively t)
(<span style="color: #a020f0;">setq</span> org-confirm-babel-evaluate nil) <span style="color: #b22222;">;; </span><span style="color: #b22222;">danger!</span>
(custom-set-faces
 <span style="color: #b22222;">;; </span><span style="color: #b22222;">custom-set-faces was added by Custom.</span>
 <span style="color: #b22222;">;; </span><span style="color: #b22222;">If you edit it by hand, you could mess it up, so be careful.</span>
 <span style="color: #b22222;">;; </span><span style="color: #b22222;">Your init file should contain only one such instance.</span>
 <span style="color: #b22222;">;; </span><span style="color: #b22222;">If there is more than one, they won't work right.</span>
 '(org-block ((t (<span style="color: #483d8b;">:inherit</span> shadow <span style="color: #483d8b;">:foreground</span> <span style="color: #8b2252;">"black"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org834f4ea" class="outline-3">
<h3 id="org834f4ea"><span class="section-number-3">1.3</span> Org Template</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Copy and paste this to demo C
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span>**<span style="color: #a0522d;">argv</span>) {
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd09923" class="outline-3">
<h3 id="orgdd09923"><span class="section-number-3">1.4</span> Remember how to compile?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
gcc -std=c99 -Wall -pedantic -Werror -o programname programname.c
</p>
</div>
</div>


<div id="outline-container-org5139fd7" class="outline-3">
<h3 id="org5139fd7"><span class="section-number-3">1.5</span> Enums!</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Enums are enumerations, which is just a convienant way to make symbols
that have different values of the same type. Enums allow us to read
and write values from files and inputs and extract their symbolic meaning.
</p>

<p>
Enums are fundamental to symbolic computation.
</p>

<p>
Enum work good for switch cases, if statements, for loops.
</p>

<p>
Enums are good for representing the type of something or a category.
</p>
</div>

<div id="outline-container-org0276f77" class="outline-4">
<h4 id="org0276f77"><span class="section-number-4">1.5.1</span> Enum Example</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Enums are good for representing states, symbols, simple values, etc.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">N_DIRECTIONS</span> 4
<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">direction</span> {
    <span style="color: #a0522d;">UP</span>=1, <span style="color: #a0522d;">DOWN</span>=2, <span style="color: #a0522d;">LEFT</span>=3, <span style="color: #a0522d;">RIGHT</span>=0
};
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">direction</span> <span style="color: #228b22;">Direction</span>;

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">direction_names</span>[N_DIRECTIONS] = {
    [UP] = <span style="color: #8b2252;">"Up"</span>,
    [DOWN] = <span style="color: #8b2252;">"Down"</span>,
    [LEFT] = <span style="color: #8b2252;">"Left"</span>,
    [RIGHT] = <span style="color: #8b2252;">"Right"</span>
};

<span style="color: #228b22;">Direction</span> <span style="color: #0000ff;">clockwise</span>(<span style="color: #228b22;">Direction</span> <span style="color: #a0522d;">direction</span>) {
    <span style="color: #a020f0;">switch</span> (direction) {
        <span style="color: #a020f0;">case</span> UP:
            <span style="color: #a020f0;">return</span> RIGHT;
        <span style="color: #a020f0;">case</span> RIGHT:
            <span style="color: #a020f0;">return</span> DOWN;
        <span style="color: #a020f0;">case</span> DOWN:
            <span style="color: #a020f0;">return</span> LEFT;
        <span style="color: #a020f0;">case</span> LEFT:
            <span style="color: #a020f0;">return</span> UP;
        <span style="color: #a020f0;">default</span>:
            abort();
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Direction</span> <span style="color: #a0522d;">d</span> = UP;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; 10; i++) {
        d = clockwise(d);
        printf(<span style="color: #8b2252;">"%d %s\t[%d]\n"</span>, i, direction_names[d], d);
    }
}
</pre>
</div>

<pre class="example">
0 Right	[0]
1 Down	[2]
2 Left	[3]
3 Up	[1]
4 Right	[0]
5 Down	[2]
6 Left	[3]
7 Up	[1]
8 Right	[0]
9 Down	[2]
</pre>
</div>
</div>

<div id="outline-container-orgd818c9b" class="outline-4">
<h4 id="orgd818c9b"><span class="section-number-4">1.5.2</span> enum<sub>typedef.c</sub></h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Enums are annoying to type. Typing enum enumname all the time is
repetitive. Typedefs allow us to label enum types with 1 word.
</p>

<p>
Typedef this 
</p>

<p>
enum enumname { &#x2026; } ;
</p>

<p>
with:
</p>

<p>
typedef enum enunumae Enumename ;
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span>,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">favourite</span> = VANILLA;
    printf(<span style="color: #8b2252;">"favourite=%d\n"</span>, favourite);
    printf(<span style="color: #8b2252;">"sizeof(favourite)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(favourite));

    <span style="color: #a020f0;">switch</span> (favourite) {
        <span style="color: #a020f0;">case</span> VANILLA:
            printf(<span style="color: #8b2252;">"favourite=VANILLA\n"</span>);
            <span style="color: #a020f0;">break</span>;
        <span style="color: #a020f0;">case</span> CHOCOLATE:
            printf(<span style="color: #8b2252;">"favourite=CHOCOLATE\n"</span>);
            <span style="color: #a020f0;">break</span>;
        <span style="color: #a020f0;">case</span> STRAWBERRY:
            printf(<span style="color: #8b2252;">"favourite=STRAWBERRY\n"</span>);
            <span style="color: #a020f0;">break</span>;
        <span style="color: #a020f0;">default</span>:
            abort();
    }
}
</pre>
</div>

<pre class="example">
favourite=0
sizeof(favourite)=4
favourite=VANILLA

</pre>
</div>
</div>



<div id="outline-container-org20adc4b" class="outline-4">
<h4 id="org20adc4b"><span class="section-number-4">1.5.3</span> EnumStart</h4>
<div class="outline-text-4" id="text-1-5-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span> = 100,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #0000ff;">flavorString</span>(<span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span>) {
    <span style="color: #a020f0;">switch</span> (flavor) {
        <span style="color: #a020f0;">case</span> VANILLA:
            <span style="color: #a020f0;">return</span> <span style="color: #8b2252;">"Vanilla"</span>;
        <span style="color: #a020f0;">case</span> CHOCOLATE:
            <span style="color: #a020f0;">return</span> <span style="color: #8b2252;">"Chocolate"</span>;
        <span style="color: #a020f0;">default</span>:
            abort();
    }
}


<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"VANILLA=%d\n"</span>, VANILLA);
    printf(<span style="color: #8b2252;">"CHOCOLATE=%d\n"</span>, CHOCOLATE);
    printf(<span style="color: #8b2252;">"STRAWBERRY=%d\n"</span>, STRAWBERRY);
    printf(<span style="color: #8b2252;">"sizeof(Flavor)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(Flavor));
    puts(flavorString(VANILLA));
    puts(flavorString(100));

}
</pre>
</div>

<pre class="example">
VANILLA=100
CHOCOLATE=101
STRAWBERRY=102
sizeof(Flavor)=4
Vanilla
Vanilla

</pre>
</div>
</div>

<div id="outline-container-org4a7ae7d" class="outline-4">
<h4 id="org4a7ae7d"><span class="section-number-4">1.5.4</span> Enumassign</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span> = 100,
    <span style="color: #a0522d;">CHOCOLATE</span> = 200,
    <span style="color: #a0522d;">STRAWBERRY</span> = 300,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"VANILLA=%d\n"</span>, VANILLA);
    printf(<span style="color: #8b2252;">"CHOCOLATE=%d\n"</span>, CHOCOLATE);
    printf(<span style="color: #8b2252;">"STRAWBERRY=%d\n"</span>, STRAWBERRY);
    printf(<span style="color: #8b2252;">"sizeof(Flavor)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(Flavor));
}
</pre>
</div>

<pre class="example">
VANILLA=100
CHOCOLATE=200
STRAWBERRY=300
sizeof(Flavor)=4

</pre>
</div>
</div>

<div id="outline-container-org60b11b3" class="outline-4">
<h4 id="org60b11b3"><span class="section-number-4">1.5.5</span> Enum<sub>loop</sub><sub>trick.c</sub></h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
This is a fun trick to set a maximum value for your enum by using
another symbol
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">this only works as long as we don't provide our</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">own values!</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span>,
    <span style="color: #a0522d;">RHUBARB</span>,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
    <span style="color: #a0522d;">N_FLAVORS</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">Get the free max enum here</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"VANILLA=%d\n"</span>, VANILLA);
    printf(<span style="color: #8b2252;">"CHOCOLATE=%d\n"</span>, CHOCOLATE);
    printf(<span style="color: #8b2252;">"STRAWBERRY=%d\n"</span>, STRAWBERRY);
    printf(<span style="color: #8b2252;">"N_FLAVORS=%d\n"</span>, N_FLAVORS);
    printf(<span style="color: #8b2252;">"sizeof(Flavor)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(Flavor));

    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span> = 0; flavor &lt; N_FLAVORS; flavor++) {
        <span style="color: #a020f0;">switch</span> (flavor) {
            <span style="color: #a020f0;">case</span> VANILLA:
                printf(<span style="color: #8b2252;">"flavor=VANILLA\n"</span>);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> CHOCOLATE:
                printf(<span style="color: #8b2252;">"flavor=CHOCOLATE\n"</span>);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> STRAWBERRY:
                printf(<span style="color: #8b2252;">"flavor=STRAWBERRY\n"</span>);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> RHUBARB:
                printf(<span style="color: #8b2252;">"flavor=RHUBARB\n"</span>);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">default</span>:
                abort();
        }
    }
}
</pre>
</div>

<pre class="example">
VANILLA=0
CHOCOLATE=2
STRAWBERRY=3
N_FLAVORS=4
sizeof(Flavor)=4
flavor=VANILLA
flavor=RHUBARB
flavor=CHOCOLATE
flavor=STRAWBERRY

</pre>
</div>
</div>

<div id="outline-container-orgc14056f" class="outline-4">
<h4 id="orgc14056f"><span class="section-number-4">1.5.6</span> Enum Int</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
Enum are just integers. And you can treat them as such.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span>,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
    <span style="color: #a0522d;">N_FLAVORS</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">LOOK MA! No Defines! Cute trick, might surprise people.</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #b22222;">// </span><span style="color: #b22222;">Here we use the fact that enums are really just ints!</span>
<span style="color: #228b22;">Flavor</span> <span style="color: #0000ff;">random_flavor</span>() {
    <span style="color: #a020f0;">return</span> (rand() % N_FLAVORS);
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">check_flavor</span>(<span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span>) {
    <span style="color: #a020f0;">if</span> (flavor &gt;= N_FLAVORS) {
        abort();
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Since a flavor is just an int, it could be negative...</span>
    <span style="color: #a020f0;">if</span> (flavor &lt; 0) {
        abort();
    }
}

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #0000ff;">get_flavor_name</span>(<span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span>) {
    check_flavor(flavor);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Here we use "Designated Initializers"!</span>
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">flavor_names</span>[N_FLAVORS] = {
        [CHOCOLATE] = <span style="color: #8b2252;">"Hamburger flavor"</span>,
        [VANILLA] = <span style="color: #8b2252;">"Raspberry"</span>,
        [STRAWBERRY] = <span style="color: #8b2252;">"Those packets that come in the ramen"</span>
    };
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">flavor_name</span> = flavor_names[flavor];
    <span style="color: #a020f0;">return</span> flavor_name;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; 4; i++) {
       <span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span> = random_flavor();
       printf(
           <span style="color: #8b2252;">"flavor %d = %s\n"</span>,
           flavor,
           get_flavor_name(flavor)
       );
    }
}
</pre>
</div>

<pre class="example">
flavor 2 = Those packets that come in the ramen
flavor 0 = Raspberry
flavor 0 = Raspberry
flavor 0 = Raspberry

</pre>
</div>
</div>

<div id="outline-container-org7b88e2a" class="outline-4">
<h4 id="org7b88e2a"><span class="section-number-4">1.5.7</span> Another motivating ENUM Example</h4>
<div class="outline-text-4" id="text-1-5-7">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #b22222;">// </span><span style="color: #b22222;">A flush is a hand where all cards have the same suit</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">like 5 diamonds or 5 hearts</span>
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[5] = {
        {ACE, CLUBS},
        {FACE2, CLUBS},
        {KING, CLUBS},
        {JACK, CLUBS},
        {FACE4, CLUBS}
    };
    printf(<span style="color: #8b2252;">"isFlush? %u\n"</span>, isFlush(hand));
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">secondHand</span>[5] = {
        {ACE, CLUBS},
        {ACE, SPADES},
        {ACE, HEARTS},
        {ACE, DIAMONDS},
        {ACE, CLUBS} <span style="color: #b22222;">// </span><span style="color: #b22222;">CHEATER</span>
    };
    printf(<span style="color: #8b2252;">"isFlush? %u\n"</span>, isFlush(secondHand));

}
</pre>
</div>

<pre class="example">
isFlush? 1
isFlush? 0

</pre>
</div>
</div>
</div>



<div id="outline-container-org2d4e8f8" class="outline-3">
<h3 id="org2d4e8f8"><span class="section-number-3">1.6</span> Unions</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>Unions are a way to all the same types to share the same memory.</li>
<li>Some types like unsigned integers have different sizes:</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"sizeof(unsigned char):\t\t%ld\n"</span>, 
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>));
    printf(<span style="color: #8b2252;">"sizeof(unsigned short):\t\t%ld\n"</span>, 
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">short</span>));
    printf(<span style="color: #8b2252;">"sizeof(unsigned int):\t\t%ld\n"</span>, 
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span>));
    printf(<span style="color: #8b2252;">"sizeof(unsigned long):\t\t%ld\n"</span>, 
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span>));
    printf(<span style="color: #8b2252;">"sizeof(unsigned long long):\t%ld\n"</span>, 
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span>));
    printf(<span style="color: #8b2252;">"sizeof(unsigned long long int):\t%ld\n"</span>, 
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">int</span>));

}
</pre>
</div>

<pre class="example">
sizeof(unsigned char):		1
sizeof(unsigned short):		2
sizeof(unsigned int):		4
sizeof(unsigned long):		8
sizeof(unsigned long long):	8
sizeof(unsigned long long int):	8

</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #b22222;">/*</span>
<span style="color: #b22222;">[C][S][I][I][L][L][L][L]</span>
<span style="color: #b22222;"> S  I  L  L</span>
<span style="color: #b22222;"> I  L</span>
<span style="color: #b22222;"> L</span>
<span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">union</span> <span style="color: #228b22;">uints</span> {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">a_char</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">short</span> <span style="color: #a0522d;">a_short</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">an_int</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">a_long</span>;
};
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">union</span> <span style="color: #228b22;">uints</span> <span style="color: #228b22;">UInts</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">EXAMPLES</span> 7
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">longs</span>[EXAMPLES] = 
        { 0, 1000, 1000000, 10000000000, 
          65535, 4294967295, 18446744073709551615UL };
    <span style="color: #228b22;">UInts</span> <span style="color: #a0522d;">uints</span>;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; EXAMPLES; i++) {
        uints.a_long = longs[i];
        printf(<span style="color: #8b2252;">"For the long %lu:\n"</span>, longs[i]);
        printf(<span style="color: #8b2252;">"\tchar\t %hhu\n"</span>, uints.a_char);
        printf(<span style="color: #8b2252;">"\tshort\t %hu\n"</span>, uints.a_short);
        printf(<span style="color: #8b2252;">"\tint\t %u\n"</span>, uints.an_int);
        printf(<span style="color: #8b2252;">"\tlong\t %lu\n"</span>, uints.a_long);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">lets see if we can overflow</span>
    uints.a_char++;
    printf(<span style="color: #8b2252;">"Overflow kept local\t %lu\n"</span>, uints.a_long);
}
</pre>
</div>

<pre class="example">
For the long 0:
	char	 0
	short	 0
	int	 0
	long	 0
For the long 1000:
	char	 232
	short	 1000
	int	 1000
	long	 1000
For the long 1000000:
	char	 64
	short	 16960
	int	 1000000
	long	 1000000
For the long 10000000000:
	char	 0
	short	 58368
	int	 1410065408
	long	 10000000000
For the long 65535:
	char	 255
	short	 65535
	int	 65535
	long	 65535
For the long 4294967295:
	char	 255
	short	 65535
	int	 4294967295
	long	 4294967295
For the long 18446744073709551615:
	char	 255
	short	 65535
	int	 4294967295
	long	 18446744073709551615
Overflow kept local	 18446744073709551360
</pre>
</div>

<div id="outline-container-orgcc8debe" class="outline-4">
<h4 id="orgcc8debe"><span class="section-number-4">1.6.1</span> Structs versus Unions</h4>
<div class="outline-text-4" id="text-1-6-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">uints</span> {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">a_char</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">short</span> <span style="color: #a0522d;">a_short</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">an_int</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">a_long</span>;
};
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">uints</span> <span style="color: #228b22;">UInts</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">UInts</span> <span style="color: #a0522d;">uints</span>;
    uints.a_long = 0;
    printf(<span style="color: #8b2252;">"Hi I'm a struct!\n"</span>);
    printf(<span style="color: #8b2252;">"sizeof(uints)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints));
    printf(<span style="color: #8b2252;">"sizeof(uints.a_char)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.a_char));
    printf(<span style="color: #8b2252;">"sizeof(uints.a_short)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.a_short));
    printf(<span style="color: #8b2252;">"sizeof(uints.an_int)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.an_int));
    printf(<span style="color: #8b2252;">"sizeof(uints.a_long)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.a_long));
    printf(<span style="color: #8b2252;">"&amp;uints=        %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;uints);
    printf(<span style="color: #8b2252;">"&amp;uints.a_char= %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.a_char));
    printf(<span style="color: #8b2252;">"&amp;uints.a_short=%p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.a_short));
    printf(<span style="color: #8b2252;">"&amp;uints.an_int= %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.an_int));
    printf(<span style="color: #8b2252;">"&amp;uints.a_long= %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.a_long));
}
</pre>
</div>

<pre class="example">
Hi I'm a struct!
sizeof(uints)=16
sizeof(uints.a_char)=1
sizeof(uints.a_short)=2
sizeof(uints.an_int)=4
sizeof(uints.a_long)=8
&amp;uints=        0x7ffc6a631fb0
&amp;uints.a_char= 0x7ffc6a631fb0
&amp;uints.a_short=0x7ffc6a631fb2
&amp;uints.an_int= 0x7ffc6a631fb4
&amp;uints.a_long= 0x7ffc6a631fb8
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #a020f0;">union</span> <span style="color: #228b22;">uints</span> {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">a_char</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">short</span> <span style="color: #a0522d;">a_short</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">an_int</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">a_long</span>;
};
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">union</span> <span style="color: #228b22;">uints</span> <span style="color: #228b22;">UInts</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">UInts</span> <span style="color: #a0522d;">uints</span>;
    uints.a_long = 0;
    printf(<span style="color: #8b2252;">"Hi I'm a Union!\n"</span>);
    printf(<span style="color: #8b2252;">"sizeof(uints)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints));
    printf(<span style="color: #8b2252;">"sizeof(uints.a_char)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.a_char));
    printf(<span style="color: #8b2252;">"sizeof(uints.a_short)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.a_short));
    printf(<span style="color: #8b2252;">"sizeof(uints.an_int)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.an_int));
    printf(<span style="color: #8b2252;">"sizeof(uints.a_long)=%zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(uints.a_long));
    printf(<span style="color: #8b2252;">"&amp;uints=        %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;uints);
    printf(<span style="color: #8b2252;">"&amp;uints.a_char= %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.a_char));
    printf(<span style="color: #8b2252;">"&amp;uints.a_short=%p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.a_short));
    printf(<span style="color: #8b2252;">"&amp;uints.an_int= %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.an_int));
    printf(<span style="color: #8b2252;">"&amp;uints.a_long= %p\n"</span>, (<span style="color: #228b22;">void</span> *) &amp;(uints.a_long));
}
</pre>
</div>

<pre class="example">
Hi I'm a Union!
sizeof(uints)=8
sizeof(uints.a_char)=1
sizeof(uints.a_short)=2
sizeof(uints.an_int)=4
sizeof(uints.a_long)=8
&amp;uints=        0x7ffd8beb4160
&amp;uints.a_char= 0x7ffd8beb4160
&amp;uints.a_short=0x7ffd8beb4160
&amp;uints.an_int= 0x7ffd8beb4160
&amp;uints.a_long= 0x7ffd8beb4160
</pre>
</div>
</div>


<div id="outline-container-org5455fdf" class="outline-4">
<h4 id="org5455fdf"><span class="section-number-4">1.6.2</span> Union considerations</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>they are aligned at the starting byte of each member.</li>
<li>overflows are kept local to the member being addressed</li>
</ul>
</div>
</div>

<div id="outline-container-orgf72751f" class="outline-4">
<h4 id="orgf72751f"><span class="section-number-4">1.6.3</span> Type Punning</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>Type punning is breaking the type system to achieve a goal</li>
<li>in C it is undefined behaviour to write to 1 part of the union
and then read from that data using a different overlapping
member. Yet it pretty common practice.</li>
<li>GCC and others typically allow it.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;limits.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">This is super useful, but we can't do it in C99 </span><span style="color: #b22222;">*/</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">multi_type</span> {
    <span style="color: #a020f0;">enum</span> {
        <span style="color: #a0522d;">NOTHING</span>,
        <span style="color: #a0522d;">AN_INT</span>,
        <span style="color: #a0522d;">A_FLOAT</span>
    } <span style="color: #a0522d;">which</span>;
    <span style="color: #a020f0;">union</span> {
        <span style="color: #228b22;">int32_t</span> <span style="color: #a0522d;">an_int</span>;
        <span style="color: #228b22;">float</span> <span style="color: #a0522d;">a_float</span>;
    };
};
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">multi_type</span> <span style="color: #228b22;">MultiType</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_mt</span>(<span style="color: #228b22;">MultiType</span> <span style="color: #a0522d;">mt</span>) {
    <span style="color: #a020f0;">if</span> (mt.which == NOTHING) {
        printf(<span style="color: #8b2252;">"nothing"</span>);
    } <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (mt.which == AN_INT) {
        printf(<span style="color: #8b2252;">"%d"</span>, (<span style="color: #228b22;">int</span>) mt.an_int);
    } <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (mt.which == A_FLOAT) {
        printf(<span style="color: #8b2252;">"%e"</span>, mt.a_float);
    } <span style="color: #a020f0;">else</span> {
        abort();
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_mt_array</span>(<span style="color: #228b22;">MultiType</span> *<span style="color: #a0522d;">mt_array</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">length</span>) {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">idx</span>;
    <span style="color: #a020f0;">for</span> (idx = 0; idx &lt; length; idx++) {
        print_mt(mt_array[idx]);
        printf(<span style="color: #8b2252;">" "</span>);
    }
    printf(<span style="color: #8b2252;">"\n"</span>);
}

<span style="color: #228b22;">MultiType</span> <span style="color: #0000ff;">new_mt_int</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">MultiType</span> <span style="color: #a0522d;">new</span>;
    new.which = AN_INT;
    new.an_int = value;
    <span style="color: #a020f0;">return</span> new;
}

<span style="color: #228b22;">MultiType</span> <span style="color: #0000ff;">new_mt_float</span>(<span style="color: #228b22;">float</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">MultiType</span> <span style="color: #a0522d;">new</span>;
    new.which = A_FLOAT;
    new.a_float = value;
    <span style="color: #a020f0;">return</span> new;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">MultiType</span> <span style="color: #a0522d;">mt_array</span>[4] = { { NOTHING } };
    mt_array[0] = new_mt_int(24);
    mt_array[1] = new_mt_int(48);
    mt_array[2] = new_mt_float(0.24);
    mt_array[3] = new_mt_float(0.12);
    printf(<span style="color: #8b2252;">"\n"</span>);
    print_mt_array(mt_array, 4);
}
</pre>
</div>

<p>
The error message:
</p>

<p>
/tmp/babel-27627ARt/C-src-27627FnU.c:24:6: error: ISO C99 doesnt support unnamed structs/unions [-Werror=pedantic]
     };
      ^
cc1: all warnings being treated as errors
/bin/bash: /tmp/babel-27627ARt/C-bin-27627Sxa: Permission denied
</p>
</div>
</div>


<div id="outline-container-orgab047e8" class="outline-4">
<h4 id="orgab047e8"><span class="section-number-4">1.6.4</span> Unions with type tags</h4>
<div class="outline-text-4" id="text-1-6-4">
<p>
It is common practice to treat unions like "dynamic types". But it is
common practice to leave a hint in a tag to what type is actually
being stored in that union.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;limits.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Multitype is either NOTHING, AN_INT, or A_FLOAT</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">You should read it and write it based on its type (which)</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">multi_type</span> {
    <span style="color: #a020f0;">enum</span> {
        <span style="color: #a0522d;">NOTHING</span>,
        <span style="color: #a0522d;">AN_INT</span>,
        <span style="color: #a0522d;">A_FLOAT</span>
    } <span style="color: #a0522d;">which</span>;
    <span style="color: #a020f0;">union</span> {
        <span style="color: #228b22;">int32_t</span> <span style="color: #a0522d;">an_int</span>;
        <span style="color: #228b22;">float</span> <span style="color: #a0522d;">a_float</span>;
    } <span style="color: #a0522d;">value</span>;
};
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">multi_type</span> <span style="color: #228b22;">MultiType</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_mt</span>(<span style="color: #228b22;">MultiType</span> <span style="color: #a0522d;">mt</span>) {
    <span style="color: #a020f0;">if</span> (mt.which == NOTHING) {
        printf(<span style="color: #8b2252;">"nothing"</span>);
    } <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (mt.which == AN_INT) {
        printf(<span style="color: #8b2252;">"%d"</span>, (<span style="color: #228b22;">int</span>) mt.value.an_int);
    } <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (mt.which == A_FLOAT) {
        printf(<span style="color: #8b2252;">"%e"</span>, mt.value.a_float);
    } <span style="color: #a020f0;">else</span> {
        abort();
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_mt_array</span>(<span style="color: #228b22;">MultiType</span> *<span style="color: #a0522d;">mt_array</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">length</span>) {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">idx</span> = 0; idx &lt; length; idx++) {
        print_mt(mt_array[idx]);
        printf(<span style="color: #8b2252;">" "</span>);
    }
    printf(<span style="color: #8b2252;">"\n"</span>);
}
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">EXAMPLES</span> 7
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">MultiType</span> <span style="color: #a0522d;">mt_array</span>[EXAMPLES] = {
        { NOTHING },
        { AN_INT, { .an_int=10 } },
        { A_FLOAT, { .a_float=0.1 } },
        { NOTHING },
        { A_FLOAT, { .a_float=99.9 } },
        { AN_INT, { .an_int=99.9 } },
        { AN_INT, { .a_float=-99.9 } },
    };
    printf(<span style="color: #8b2252;">"\n"</span>);
    printf(<span style="color: #8b2252;">"sizeof(mt_array)    == %lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(mt_array));
    printf(<span style="color: #8b2252;">"sizeof(mt_array[0]) == %lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(mt_array[0]));
    printf(<span style="color: #8b2252;">"sizeof(mt_array[1]) == %lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(mt_array[1]));
    printf(<span style="color: #8b2252;">"sizeof(mt_array[2]) == %lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(mt_array[2]));
    print_mt_array(mt_array, EXAMPLES);
}
</pre>
</div>

<pre class="example">
sizeof(mt_array)    == 56
sizeof(mt_array[0]) == 8
sizeof(mt_array[1]) == 8
sizeof(mt_array[2]) == 8
nothing 10 1.000000e-01 nothing 9.990000e+01 99 -1027093299

</pre>
</div>
</div>
</div>

<div id="outline-container-org1070be1" class="outline-3">
<h3 id="org1070be1"><span class="section-number-3">1.7</span> Malloc! The Heap!</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Memory!
</p>

<p>
Your programs use the following kinds of memory:
</p>
<ul class="org-ul">
<li>Code: this is for constants and compiled code for the CPU to run</li>
<li>Data: this is for strings, literals, and other values you predefine
in your program.</li>
<li>Stack: this is where the data for your function locals goes</li>
<li>Heap: this is where dynamically allocated memory goes. It is the largest pool.</li>
</ul>

<p>
What memory does our program use? (OS and compiler specific)
</p>
<ul class="org-ul">
<li>Globals? Data.</li>
<li>Static variables? Data.</li>
<li>Constants? Code and or Data</li>
<li>Local variables? stack</li>
<li>Dynamic allocation? heap</li>
</ul>
</div>

<div id="outline-container-org8ad14c4" class="outline-4">
<h4 id="org8ad14c4"><span class="section-number-4">1.7.1</span> On my computer</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
Here's what emacs is using
</p>

<pre class="example">
root@st-francis:/proc/27627# cat maps
00400000-00641000 r-xp 00000000 09:00 116130283                          /usr/bin/emacs25-x
00841000-00848000 r--p 00241000 09:00 116130283                          /usr/bin/emacs25-x
00848000-01615000 rw-p 00248000 09:00 116130283                          /usr/bin/emacs25-x
03155000-0d208000 rw-p 00000000 00:00 0                                  [heap]
7f16739f4000-7f1673a74000 rw-s 00000000 00:05 935100458                  /SYSV00000000 (deleted)
7f1673a74000-7f1673a79000 r-xp 00000000 09:00 394799                     /usr/lib/x86_64-linux-gnu/gdk-pixbuf-2.0/2.10.0/loaders/libpixbufloader-png.so
7f1673a79000-7f1673c78000 ---p 00005000 09:00 394799                     /usr/lib/x86_64-linux-gnu/gdk-pixbuf-2.0/2.10.0/loaders/libpixbufloader-png.so
7f1673c78000-7f1673c79000 r--p 00004000 09:00 394799                     /usr/lib/x86_64-linux-gnu/gdk-pixbuf-2.0/2.10.0/loaders/libpixbufloader-png.so
...
7f168942a000-7f168942b000 r--p 00027000 09:00 103024636                  /lib/x86_64-linux-gnu/ld-2.27.so
7f168942b000-7f168942c000 rw-p 00028000 09:00 103024636                  /lib/x86_64-linux-gnu/ld-2.27.so
7f168942c000-7f168942d000 rw-p 00000000 00:00 0 
7fffcf9ad000-7fffcfa6d000 rw-p 00000000 00:00 0                          [stack]
7fffcfb29000-7fffcfb2c000 r--p 00000000 00:00 0                          [vvar]
7fffcfb2c000-7fffcfb2e000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</pre>

<p>
Here's the important lines
</p>
<pre class="example">
code        00400000-00641000 r-xp 00000000 09:00 116130283                          /usr/bin/emacs25-x
data?       00841000-00848000 r--p 00241000 09:00 116130283                          /usr/bin/emacs25-x
data?       00848000-01615000 rw-p 00248000 09:00 116130283                          /usr/bin/emacs25-x
heap        03155000-0d208000 rw-p 00000000 00:00 0                                  [heap]
stack       7fffcf9ad000-7fffcfa6d000 rw-p 00000000 00:00 0                          [stack]
</pre>

<p>
So stack is limited
</p>

<pre class="example">
hindle1@st-francis:~$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 273535
max locked memory       (kbytes, -l) 16384
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 273535
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</pre>


<pre class="example">
stack size              (kbytes, -s) 8192
</pre>

<p>
8megs of stack.
</p>

<p>
What if I want a big array?
</p>

<p>
I can tell bash to give me more, but sometimes you are limited.
</p>

<p>
How do programs using more than 8mb of memory?
</p>

<p>
THE HEAP!!
</p>

<p>
How do I get heap memory?
</p>

<p>
malloc!
</p>

<p>
Can I get it any time.
</p>

<p>
Sure.
</p>
</div>
</div>

<div id="outline-container-org46291f3" class="outline-4">
<h4 id="org46291f3"><span class="section-number-4">1.7.2</span> Malloc</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Just stack allocation
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">allocAndGo</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">len</span>) {
        <span style="color: #228b22;">int</span> <span style="color: #a0522d;">bigArray</span>[len];
        <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">idx</span>=0; idx &lt; len; idx++) {
            bigArray[idx] = idx;
        }
        printf(<span style="color: #8b2252;">"%u ints allocated!\n"</span>,1+bigArray[len-1]);
        printf(<span style="color: #8b2252;">"%lu bytes!\n"</span>, <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>)*len);
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">let's find the max of the stack.</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1; i &lt; 900000; i+=256*1024) {
        allocAndGo(i);
    }
}
</pre>
</div>

<pre class="example">
1 ints allocated!
4 bytes!
262145 ints allocated!
1048580 bytes!
524289 ints allocated!
2097156 bytes!
786433 ints allocated!
3145732 bytes!

</pre>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #228b22;">int</span> * <span style="color: #0000ff;">testAllocArray</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">arrLen</span>) {
  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span> = arrLen * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>);
  <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">array</span> = malloc( size );
  assert(array!=<span style="color: #008b8b;">NULL</span>);
  memset((<span style="color: #228b22;">void</span>*)array, 0, size);
  <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">idx</span>=0; idx&lt;arrLen; idx++) {
    array[idx] = idx;
  }
  <span style="color: #a020f0;">return</span> array;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1; i &lt; 90000000; i+=5*1024*1024) {
        <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">bigArray</span> = testAllocArray( i );
        printf(<span style="color: #8b2252;">"%u ints allocated!\n"</span>,1+bigArray[i-1]);
        printf(<span style="color: #8b2252;">"%lu bytes!\n"</span>, <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>)*i);
        free(bigArray); <span style="color: #b22222;">// </span><span style="color: #b22222;">remember to free it when done!</span>
    }
}
</pre>
</div>

<pre class="example">
1 ints allocated!
4 bytes!
5242881 ints allocated!
20971524 bytes!
10485761 ints allocated!
41943044 bytes!
15728641 ints allocated!
62914564 bytes!
20971521 ints allocated!
83886084 bytes!
26214401 ints allocated!
104857604 bytes!
31457281 ints allocated!
125829124 bytes!
36700161 ints allocated!
146800644 bytes!
41943041 ints allocated!
167772164 bytes!
47185921 ints allocated!
188743684 bytes!
52428801 ints allocated!
209715204 bytes!
57671681 ints allocated!
230686724 bytes!
62914561 ints allocated!
251658244 bytes!
68157441 ints allocated!
272629764 bytes!
73400321 ints allocated!
293601284 bytes!
78643201 ints allocated!
314572804 bytes!
83886081 ints allocated!
335544324 bytes!
89128961 ints allocated!
356515844 bytes!
</pre>
</div>
</div>

<div id="outline-container-orgbe3b70c" class="outline-4">
<h4 id="orgbe3b70c"><span class="section-number-4">1.7.3</span> Malloc2</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
Big allocation!
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -Wall -pedantic -Werror -o board ./board.c
./board | wc
</pre>
</div>

<pre class="example">
8192    8192 67117056

</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">&lt;-- malloc is in stdlib.h</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">KIBI</span> 1024L
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MEGA</span> (KIBI*KIBI)
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SIZE</span> 1024*8

<span style="color: #b22222;">/*</span>
<span style="color: #b22222;"> * malloc: Memory ALLOCate, in number of bytes</span>
<span style="color: #b22222;"> * free: deallocate the memory</span>
<span style="color: #b22222;"> *  takes the pointer returned by malloc</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * Memory still needs to be initialized!</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #228b22;">uint8_t</span> * <span style="color: #0000ff;">get_board</span>() {
    <span style="color: #228b22;">void</span> * <span style="color: #a0522d;">allocated</span> = malloc(<span style="color: #a020f0;">sizeof</span>(uint8_t) * SIZE * SIZE);
    <span style="color: #a020f0;">if</span> (allocated == <span style="color: #008b8b;">NULL</span>) {
        printf(<span style="color: #8b2252;">"Error: Out of memory!\n"</span>);
        abort();
    }
    <span style="color: #a020f0;">return</span> allocated;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">uint8_t</span> (*<span style="color: #a0522d;">board</span>)[SIZE] = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">total_size</span> = <span style="color: #a020f0;">sizeof</span>(uint8_t) * SIZE * SIZE;
    board = (<span style="color: #228b22;">uint8_t</span> (*)[SIZE])get_board();
    <span style="color: #b22222;">// </span><span style="color: #b22222;">board = malloc(total_size);</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">row</span> = 0; row &lt; SIZE; row++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">col</span> = 0; col &lt; SIZE; col++) {
            board[row][col] = rand() % 26 + <span style="color: #8b2252;">'A'</span>;
        }
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">row</span> = 0; row &lt; SIZE; row++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">col</span> = 0; col &lt; SIZE; col++) {
            printf(<span style="color: #8b2252;">"%c"</span>, (<span style="color: #228b22;">char</span>) board[row][col]);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
    printf(<span style="color: #8b2252;">"board is %zu mebibytes!\n"</span>, total_size/MEGA);
    free(board);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">row</span> = 0; row &lt; SIZE; row++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">col</span> = 0; col &lt; SIZE; col++) {
            printf(<span style="color: #8b2252;">"%c"</span>, (<span style="color: #228b22;">char</span>) board[row][col]);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org395c784" class="outline-4">
<h4 id="org395c784"><span class="section-number-4">1.7.4</span> Calloc</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
Calloc is like malloc except it will initialize the memory for you!
Just to 0 though. Which is good enough.
</p>

<p>
Calloc looks different 
</p>

<p>
man calloc says
</p>

<p>
void *calloc(size<sub>t</sub> nmemb, size<sub>t</sub> size);
</p>

<p>
It's not void, it's void * so you have to cast.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #228b22;">int</span> * <span style="color: #0000ff;">testAllocArray</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">arrLen</span>) {
  <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">array</span> = calloc( <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>), arrLen );
  assert(array!=<span style="color: #008b8b;">NULL</span>);
  <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">idx</span>=0; idx&lt;arrLen; idx++) {
    array[idx] = idx;
  }
  <span style="color: #a020f0;">return</span> array;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1; i &lt; 90000000; i+=5*1024*1024) {
        <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">bigArray</span> = testAllocArray( i );
        printf(<span style="color: #8b2252;">"%u ints allocated!\n"</span>,1+bigArray[i-1]);
        printf(<span style="color: #8b2252;">"%lu bytes!\n"</span>, <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>)*i);
        free(bigArray); <span style="color: #b22222;">// </span><span style="color: #b22222;">remember to free it when done!</span>
    }
}
</pre>
</div>

<pre class="example">
1 ints allocated!
4 bytes!
5242881 ints allocated!
20971524 bytes!
10485761 ints allocated!
41943044 bytes!
15728641 ints allocated!
62914564 bytes!
20971521 ints allocated!
83886084 bytes!
26214401 ints allocated!
104857604 bytes!
31457281 ints allocated!
125829124 bytes!
36700161 ints allocated!
146800644 bytes!
41943041 ints allocated!
167772164 bytes!
47185921 ints allocated!
188743684 bytes!
52428801 ints allocated!
209715204 bytes!
57671681 ints allocated!
230686724 bytes!
62914561 ints allocated!
251658244 bytes!
68157441 ints allocated!
272629764 bytes!
73400321 ints allocated!
293601284 bytes!
78643201 ints allocated!
314572804 bytes!
83886081 ints allocated!
335544324 bytes!
89128961 ints allocated!
356515844 bytes!
</pre>
</div>
</div>

<div id="outline-container-orgf631b7a" class="outline-4">
<h4 id="orgf631b7a"><span class="section-number-4">1.7.5</span> strdup</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
strdup duplicates a string into newly malloc'd memory.
</p>

<p>
Very handy.
</p>

<p>
Very dangerous.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_POSIX_C_SOURCE</span> 200809L <span style="color: #b22222;">// </span><span style="color: #b22222;">&lt;-- needed for strdup</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">&lt;-- strdup is in string.h</span>

<span style="color: #b22222;">/*</span>
<span style="color: #b22222;"> * strdup = malloc + strcpy</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">message</span> = <span style="color: #8b2252;">"hello, world!"</span>;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">char buffer[14];</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">strncpy(buffer, message, 14);    </span>
    printf(<span style="color: #8b2252;">"%p %s\n"</span>, (<span style="color: #228b22;">void</span>*)message, message);    
    <span style="color: #b22222;">// </span><span style="color: #b22222;">hi this code is basically strdup</span>
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">copyMalloc</span> = malloc((strlen(message) + 1) * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">char</span>));
    strcpy(copyMalloc, message);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">^^^^ that was basically strdup</span>
    printf(<span style="color: #8b2252;">"%p %s\n"</span>, (<span style="color: #228b22;">void</span>*)copyMalloc, copyMalloc);    
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">copyDup</span> = strdup(message);
    printf(<span style="color: #8b2252;">"%p %s\n"</span>, (<span style="color: #228b22;">void</span>*)copyDup, copyDup);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&gt; .c:30:16: error: assignment of read-only location &#8216;*message&#8217;</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&gt;    message[0] = 'H';</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">message[0] = 'H';</span>
    copyDup[0] = <span style="color: #8b2252;">'J'</span>;
    copyMalloc[0] = <span style="color: #8b2252;">'M'</span>;
    printf(<span style="color: #8b2252;">"%s\n"</span>, message);    
    printf(<span style="color: #8b2252;">"%s\n"</span>, copyMalloc);    
    printf(<span style="color: #8b2252;">"%s\n"</span>, copyDup);
    free(copyDup);
    free(copyMalloc);
}
</pre>
</div>

<pre class="example">
0x55c8c5d66984 hello, world!
0x55c8c75a3270 hello, world!
0x55c8c75a3290 hello, world!
hello, world!
Mello, world!
Jello, world!

</pre>
</div>
</div>

<div id="outline-container-org0c20255" class="outline-4">
<h4 id="org0c20255"><span class="section-number-4">1.7.6</span> free</h4>
<div class="outline-text-4" id="text-1-7-6">
<p>
What happens if we don't free?
</p>

<p>
Our program can get bigger!
</p>



<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #228b22;">int</span> * <span style="color: #0000ff;">testAllocArray</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">arrLen</span>) {
  <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">array</span> = calloc( <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>), arrLen );
  assert(array!=<span style="color: #008b8b;">NULL</span>);
  <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">idx</span>=0; idx&lt;arrLen; idx++) {
    array[idx] = idx;
  }
  <span style="color: #a020f0;">return</span> array;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1; i &lt; 10000000; i+=1*1024*1024) {
        <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">bigArray</span> = testAllocArray( i );
        printf(<span style="color: #8b2252;">"%u ints allocated!\n"</span>,1+bigArray[i-1]);
        printf(<span style="color: #8b2252;">"%lu bytes!\n"</span>, <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>)*i);
        <span style="color: #b22222;">// </span><span style="color: #b22222;">free(bigArray); // remember to free it when done!</span>
    }
}
</pre>
</div>

<pre class="example">
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
</pre>

<p>
Valgrind is a memory leak detector. It analyzes memory allocations and
warns us about mistakes.
</p>

<p>
Valgrind will show us that we're leaking memory (losing track of it
and not freeing it).
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -Wall -pedantic -Werror -o nofree ./nofree.c
valgrind ./nofree 2&gt;&amp;1
<span style="color: #483d8b;">echo</span> now let<span style="color: #8b2252;">\'</span>s leak check
valgrind --leak-check=full ./nofree 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==31794== Memcheck, a memory error detector
==31794== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==31794== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==31794== Command: ./nofree
==31794== 
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
==31794== 
==31794== HEAP SUMMARY:
==31794==     in use at exit: 188,743,720 bytes in 10 blocks
==31794==   total heap usage: 11 allocs, 1 frees, 188,747,816 bytes allocated
==31794== 
==31794== LEAK SUMMARY:
==31794==    definitely lost: 100,663,320 bytes in 6 blocks
==31794==    indirectly lost: 0 bytes in 0 blocks
==31794==      possibly lost: 88,080,400 bytes in 4 blocks
==31794==    still reachable: 0 bytes in 0 blocks
==31794==         suppressed: 0 bytes in 0 blocks
==31794== Rerun with --leak-check=full to see details of leaked memory
==31794== 
==31794== For counts of detected and suppressed errors, rerun with: -v
==31794== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
now let's leak check
==31803== Memcheck, a memory error detector
==31803== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==31803== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==31803== Command: ./nofree
==31803== 
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
==31803== 
==31803== HEAP SUMMARY:
==31803==     in use at exit: 188,743,720 bytes in 10 blocks
==31803==   total heap usage: 11 allocs, 1 frees, 188,747,816 bytes allocated
==31803== 
==31803== 88,080,400 bytes in 4 blocks are possibly lost in loss record 1 of 2
==31803==    at 0x4C31B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==31803==    by 0x1086F6: testAllocArray (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==31803==    by 0x10876F: main (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==31803== 
==31803== 100,663,320 bytes in 6 blocks are definitely lost in loss record 2 of 2
==31803==    at 0x4C31B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==31803==    by 0x1086F6: testAllocArray (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==31803==    by 0x10876F: main (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==31803== 
==31803== LEAK SUMMARY:
==31803==    definitely lost: 100,663,320 bytes in 6 blocks
==31803==    indirectly lost: 0 bytes in 0 blocks
==31803==      possibly lost: 88,080,400 bytes in 4 blocks
==31803==    still reachable: 0 bytes in 0 blocks
==31803==         suppressed: 0 bytes in 0 blocks
==31803== 
==31803== For counts of detected and suppressed errors, rerun with: -v
==31803== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
</pre>
</div>
</div>

<div id="outline-container-org8ba35ef" class="outline-4">
<h4 id="org8ba35ef"><span class="section-number-4">1.7.7</span> realloc!</h4>
<div class="outline-text-4" id="text-1-7-7">
<p>
realloc does a lot of work for you!
</p>

<p>
It will use the information that malloc uses to see if it can just
leave the pointer in place and safely give it more space.
</p>

<p>
If there's not enough space it will allocate a new region of memory
and return that new pointer. It will free the old pointer if that was
the case.
</p>

<p>
There's no guarantee that you pointer stays in the same spot!
</p>

<ul class="org-ul">
<li>With realloc, you must replace the old pointer with the new one!</li>
<li>With realloc you must check if there was enough memory to do it!
<ul class="org-ul">
<li>check return value!</li>
</ul></li>
</ul>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">We're going to malloc 3 regions and keep growing it</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">by 5 characters</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">array1</span> = (<span style="color: #228b22;">char</span>*)malloc(10);
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">array2</span> = (<span style="color: #228b22;">char</span>*)malloc(20);
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">array3</span> = (<span style="color: #228b22;">char</span>*)malloc(30);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 30; i &lt; 500; i+=5) {
        <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">newArray1</span> = realloc(array1, <span style="color: #228b22;">i</span> * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">char</span>));
        <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">newArray2</span> = realloc(array2, <span style="color: #228b22;">i</span> * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">char</span>));
        <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">newArray3</span> = realloc(array3, <span style="color: #228b22;">i</span> * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">char</span>));
        assert(newArray1 != <span style="color: #008b8b;">NULL</span> || newArray2 != <span style="color: #008b8b;">NULL</span> || newArray3 != <span style="color: #008b8b;">NULL</span>);
        <span style="color: #a020f0;">if</span> ( array1 != newArray1 )  {
            printf(<span style="color: #8b2252;">"size: %05d array1: old: %p new: %p\n"</span>, i, array1, newArray1);
        }
        <span style="color: #b22222;">/*</span>
<span style="color: #b22222;">        if ( array2 != newArray2 )  {</span>
<span style="color: #b22222;">            printf("size: %05d array2: old: %p new: %p\n", i, array2, newArray2);</span>
<span style="color: #b22222;">        }</span>
<span style="color: #b22222;">        if ( array3 != newArray3 )  {</span>
<span style="color: #b22222;">            printf("size: %05d array3: old: %p new: %p\n", i, array3, newArray3);</span>
<span style="color: #b22222;">        }</span>
<span style="color: #b22222;">        </span><span style="color: #b22222;">*/</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">YOU MUST REPLACE THE OLD VALUE, IT IS DANGEROUS!</span>
        array1 = newArray1;
        array2 = newArray2;
        array3 = newArray3;
    }
    free(array1);
    free(array2);
    free(array3);
}
</pre>
</div>

<pre class="example">
size: 00030 array1: old: 0x559564e1b260 new: 0x559564e1b2d0
size: 00045 array1: old: 0x559564e1b2d0 new: 0x559564e1c340
size: 00060 array1: old: 0x559564e1c340 new: 0x559564e1c400
size: 00075 array1: old: 0x559564e1c400 new: 0x559564e1c4f0
size: 00090 array1: old: 0x559564e1c4f0 new: 0x559564e1c610
size: 00105 array1: old: 0x559564e1c610 new: 0x559564e1c760
size: 00125 array1: old: 0x559564e1c760 new: 0x559564e1c8e0
size: 00140 array1: old: 0x559564e1c8e0 new: 0x559564e1ca90
size: 00155 array1: old: 0x559564e1ca90 new: 0x559564e1cc70
size: 00170 array1: old: 0x559564e1cc70 new: 0x559564e1ce80
size: 00185 array1: old: 0x559564e1ce80 new: 0x559564e1d0c0
size: 00205 array1: old: 0x559564e1d0c0 new: 0x559564e1d330
size: 00220 array1: old: 0x559564e1d330 new: 0x559564e1d5d0
size: 00235 array1: old: 0x559564e1d5d0 new: 0x559564e1d8a0
size: 00250 array1: old: 0x559564e1d8a0 new: 0x559564e1dba0
size: 00265 array1: old: 0x559564e1dba0 new: 0x559564e1ded0
size: 00285 array1: old: 0x559564e1ded0 new: 0x559564e1e230
size: 00300 array1: old: 0x559564e1e230 new: 0x559564e1e5c0
size: 00315 array1: old: 0x559564e1e5c0 new: 0x559564e1e980
size: 00330 array1: old: 0x559564e1e980 new: 0x559564e1ed70
size: 00345 array1: old: 0x559564e1ed70 new: 0x559564e1f190
size: 00365 array1: old: 0x559564e1f190 new: 0x559564e1f5e0
size: 00380 array1: old: 0x559564e1f5e0 new: 0x559564e1fa60
size: 00395 array1: old: 0x559564e1fa60 new: 0x559564e1ff10
size: 00410 array1: old: 0x559564e1ff10 new: 0x559564e203f0
size: 00425 array1: old: 0x559564e203f0 new: 0x559564e20900
size: 00445 array1: old: 0x559564e20900 new: 0x559564e20e40
size: 00460 array1: old: 0x559564e20e40 new: 0x559564e213b0
size: 00475 array1: old: 0x559564e213b0 new: 0x559564e21950
size: 00490 array1: old: 0x559564e21950 new: 0x559564e21f20
</pre>
</div>
</div>


<div id="outline-container-org4f10e94" class="outline-4">
<h4 id="org4f10e94"><span class="section-number-4">1.7.8</span> Malloc and structs</h4>
<div class="outline-text-4" id="text-1-7-8">
<p>
Mallocs are often used with arrays of structs. You need to get the
sizeof the struct.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACES</span> 13
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACEOFF</span> 1

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NSUIT</span> 4

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">PlayingCard</span> <span style="color: #0000ff;">randomCard</span>() {
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">card</span> = {ACE, CLUBS};
    card.face = NFACEOFF + ( rand() % NFACES );
    card.suit =  rand() % NSUIT;
    <span style="color: #a020f0;">return</span> card;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">N</span> = 1000000;
    <span style="color: #228b22;">PlayingCard</span> * <span style="color: #a0522d;">bigHand</span> = malloc(<span style="color: #a020f0;">sizeof</span>(PlayingCard)*N);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; N; i++) {
        bigHand[i] = randomCard();
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flushes</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; N - HANDSIZE; i+=HANDSIZE) {
        <span style="color: #a020f0;">if</span> (isFlush(bigHand + i)) {
            <span style="color: #a020f0;">if</span> (flushes &lt; 10) { <span style="color: #b22222;">// </span><span style="color: #b22222;">reduce printing</span>
                printf(<span style="color: #8b2252;">"Flush found at card %d\n"</span>, i);
                printf(<span style="color: #8b2252;">"Suit %d\n"</span>, bigHand[i].suit);
            }
            flushes++;
        }
    }
    printf(<span style="color: #8b2252;">"We found %d flushes out of %d hands: %f\n"</span>, flushes, N/HANDSIZE, flushes/(<span style="color: #228b22;">float</span>)(N/HANDSIZE));
}


</pre>
</div>

<pre class="example">
Flush found at card 1065
Suit 3
Flush found at card 3045
Suit 3
Flush found at card 3780
Suit 1
Flush found at card 3795
Suit 0
Flush found at card 3980
Suit 1
Flush found at card 5400
Suit 1
Flush found at card 7510
Suit 3
Flush found at card 7695
Suit 1
Flush found at card 14055
Suit 0
Flush found at card 15530
Suit 3
We found 798 flushes out of 200000 hands: 0.003990
</pre>
</div>
</div>

<div id="outline-container-org4416697" class="outline-4">
<h4 id="org4416697"><span class="section-number-4">1.7.9</span> Malloc 2D arrays</h4>
<div class="outline-text-4" id="text-1-7-9">
<p>
How does Malloc work with 2D arrays? Well 2D arrays are tightly packed
so it is pretty easy to determine their size in memory.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #b22222;">// </span><span style="color: #b22222;">READ man 3 malloc</span>

<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Option 3:</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">In functions... just a 2-D array as normal...</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">...we could use either int a[n][n] OR</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">int a[][n], but NOT a[][]!</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_2d</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span>[][n]) {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            printf(<span style="color: #8b2252;">"%2d "</span>, a[i][j]);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span> **<span style="color: #a0522d;">argv</span>) {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span> = 10;
    <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">array</span> = (<span style="color: #228b22;">int</span> *) <span style="color: #b22222;">// </span><span style="color: #b22222;">cast result of malloc to "ptr to an int"</span>
        malloc(n * n * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>));
    <span style="color: #228b22;">int</span> (*<span style="color: #a0522d;">array2d</span>)[n] = (<span style="color: #228b22;">int</span> (*)[n]) array;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">k</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            <span style="color: #b22222;">// </span><span style="color: #b22222;">Option 1:</span>
            <span style="color: #b22222;">// </span><span style="color: #b22222;">Use a 1-D array and arithmetic</span>
            array[i * n + j] = k++;
        }
    }
    printf(<span style="color: #8b2252;">"Printing Option2\n\n"</span>);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            <span style="color: #b22222;">// </span><span style="color: #b22222;">Option 2:</span>
            <span style="color: #b22222;">// </span><span style="color: #b22222;">Use 2-D array</span>
            printf(<span style="color: #8b2252;">"%2d "</span>, array2d[i][j]);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
    printf(<span style="color: #8b2252;">"\nPrinting Option3\n\n"</span>);
    print_2d(n, (<span style="color: #228b22;">int</span>(*)[n]) array);
    free(array); <span style="color: #b22222;">// </span><span style="color: #b22222;">deallocates or "frees" the memory we were using for array</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Now ALL pointers to or into the array are invalid!</span>
}
</pre>
</div>

<pre class="example">
Printing Option2

 0  1  2  3  4  5  6  7  8  9 
10 11 12 13 14 15 16 17 18 19 
20 21 22 23 24 25 26 27 28 29 
30 31 32 33 34 35 36 37 38 39 
40 41 42 43 44 45 46 47 48 49 
50 51 52 53 54 55 56 57 58 59 
60 61 62 63 64 65 66 67 68 69 
70 71 72 73 74 75 76 77 78 79 
80 81 82 83 84 85 86 87 88 89 
90 91 92 93 94 95 96 97 98 99 

Printing Option3

 0  1  2  3  4  5  6  7  8  9 
10 11 12 13 14 15 16 17 18 19 
20 21 22 23 24 25 26 27 28 29 
30 31 32 33 34 35 36 37 38 39 
40 41 42 43 44 45 46 47 48 49 
50 51 52 53 54 55 56 57 58 59 
60 61 62 63 64 65 66 67 68 69 
70 71 72 73 74 75 76 77 78 79 
80 81 82 83 84 85 86 87 88 89 
90 91 92 93 94 95 96 97 98 99
</pre>
</div>
</div>

<div id="outline-container-org4c81331" class="outline-4">
<h4 id="org4c81331"><span class="section-number-4">1.7.10</span> Malloc Array of Array versus 2D</h4>
<div class="outline-text-4" id="text-1-7-10">
<p>
So instead of allocating a big block and carving a 2D array out of it
we could just allocate each row and make an array of arrays.
</p>

<p>
Try playing with the order of allocation of rows. Does it affect the result?
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">This example compares using malloc to get space for a 2-D array vs using malloc to make space for a array of arrays.</span>

<span style="color: #228b22;">int</span> * <span style="color: #0000ff;">alloc2d</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we can just do 1 malloc()</span>
    <span style="color: #a020f0;">return</span> (<span style="color: #228b22;">int</span> *) malloc(n * n * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>));
}

<span style="color: #228b22;">int</span> ** <span style="color: #0000ff;">alloc_aoa</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we have to do 1 + n malloc()s</span>
    <span style="color: #228b22;">int</span> ** <span style="color: #a0522d;">p</span> = malloc(<span style="color: #228b22;">n</span> * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span> *));
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we don't need to do them in order...</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        p[i] = malloc(<span style="color: #228b22;">n</span> * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>));
    }
    <span style="color: #a020f0;">return</span> p;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">free2d</span>(<span style="color: #228b22;">int</span> * <span style="color: #a0522d;">p</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we can just do 1 free()</span>
    free(p);
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">free_aoa</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">int</span> ** <span style="color: #a0522d;">p</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we have to do n + 1 free()s</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        free(p[i]);
    }
    free(p);
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get2d</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>) {
    <span style="color: #a020f0;">return</span> p[i * n + j];
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get_aoa</span>(<span style="color: #228b22;">int</span> **<span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>) {
    <span style="color: #a020f0;">return</span> p[i][j];
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">set2d</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">v</span>) {
    <span style="color: #a020f0;">return</span> p[i * n + j] = v;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">set_aoa</span>(<span style="color: #228b22;">int</span> **<span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">v</span>) {
    <span style="color: #a020f0;">return</span> p[i][j] = v;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span> **<span style="color: #a0522d;">argv</span>) {
    srand(1);
    printf(<span style="color: #8b2252;">"I'm going to make space for a big, square table in memory.\n"</span>);
    printf(<span style="color: #8b2252;">"How many rows and columns would you like to make space for? "</span>);
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">int r = scanf("%zu", &amp;n);</span>
    n = 30;
    <span style="color: #a020f0;">if</span> (n != 1) {
        printf(<span style="color: #8b2252;">"Sorry, I couldn't understand that :(\n"</span>);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">allocate them</span>
    <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">p2d</span> = alloc2d(n);
    <span style="color: #228b22;">int</span> **<span style="color: #a0522d;">aoa</span> = alloc_aoa(n);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">initialize them</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            set2d(n, p2d, i, j, rand() % 10);
            set_aoa(aoa, i, j, rand() % 10);
        }
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">print them out</span>
    printf(<span style="color: #8b2252;">"2d:\n"</span>);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span> = get2d(n, p2d, i, j);
            printf(<span style="color: #8b2252;">"%d "</span>, x);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
    printf(<span style="color: #8b2252;">"aoa:\n"</span>);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span> = get_aoa(aoa, i, j);
            printf(<span style="color: #8b2252;">"%d "</span>, x);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">free them</span>
    free2d(p2d);
    free_aoa(n, aoa);
}
</pre>
</div>

<pre class="example">
I'm going to make space for a big, square table in memory.
How many rows and columns would you like to make space for? Sorry, I couldn't understand that :(
2d:
3 7 3 6 9 2 0 3 0 2 1 7 2 2 7 9 2 9 3 1 9 1 4 8 5 3 1 6 2 6 
5 4 6 6 3 4 2 4 4 3 7 6 8 3 4 2 6 9 6 4 5 4 7 7 7 2 1 6 5 4 
0 1 7 1 9 7 7 6 6 9 8 2 3 0 8 0 6 8 6 1 9 4 1 3 4 4 7 3 7 9 
2 7 5 4 8 9 5 8 3 8 6 3 3 6 4 8 9 7 4 0 0 2 4 5 4 9 2 7 5 8 
2 9 6 0 1 5 1 8 0 4 2 8 2 4 2 0 2 9 8 3 1 3 0 9 9 9 3 0 6 4 
0 6 6 5 9 7 8 9 6 2 6 3 1 9 1 9 0 5 7 4 0 2 6 0 2 2 5 2 0 8 
8 4 9 9 2 4 9 3 0 0 9 3 1 4 1 6 4 2 4 2 8 2 8 6 3 3 3 0 7 8 
0 8 9 3 3 3 6 2 5 7 6 4 0 8 0 6 4 9 9 8 0 7 9 5 9 5 4 9 5 3 
7 8 9 7 2 3 9 2 1 6 1 0 3 1 0 6 7 0 4 4 5 2 0 6 6 8 6 7 1 1 
7 2 4 2 2 0 9 5 0 7 8 0 6 6 9 5 7 5 3 3 9 7 7 1 0 8 5 4 7 3 
0 7 9 2 3 1 2 2 7 1 4 7 1 7 4 8 1 6 1 6 8 8 0 2 7 6 6 7 7 9 
7 6 8 3 4 5 1 5 9 3 5 2 7 3 6 6 3 4 9 2 8 0 4 6 7 3 3 5 0 7 
3 0 0 1 3 9 4 5 8 5 5 9 7 3 6 5 6 0 1 2 9 0 2 4 3 8 3 0 3 9 
7 2 2 4 8 0 9 2 1 3 2 4 1 5 1 9 1 3 7 8 7 4 4 1 8 2 9 6 6 9 
0 9 1 8 6 7 7 2 1 0 0 0 3 4 1 0 2 7 6 4 2 7 4 6 7 5 2 3 4 9 
2 1 3 2 5 5 0 4 6 2 8 5 6 8 7 2 0 8 5 7 8 3 7 7 9 1 0 9 8 3 
0 9 1 7 7 2 1 8 4 6 6 4 8 8 5 4 0 7 2 2 3 9 1 5 4 2 1 2 2 9 
4 5 1 0 1 7 9 1 7 0 0 5 9 1 1 0 8 4 2 4 9 2 9 0 4 9 5 6 3 9 
2 3 9 1 4 8 7 3 9 5 8 0 3 1 7 5 1 3 0 5 2 9 9 9 1 3 3 4 1 6 
7 2 2 1 4 8 3 7 3 2 3 6 1 6 0 5 5 9 8 2 9 1 0 6 9 8 8 3 0 5 
3 8 1 9 0 5 4 4 9 9 3 3 7 4 9 9 2 6 9 6 1 3 2 3 9 4 4 9 8 2 
5 3 4 5 7 9 7 7 9 5 4 7 3 2 2 3 1 8 0 2 9 9 3 8 6 7 7 1 0 4 
3 3 7 1 9 6 9 5 1 9 1 2 0 3 1 7 8 0 4 3 9 4 5 2 7 8 9 3 8 4 
6 8 5 1 6 8 6 5 6 1 3 5 6 4 6 7 3 9 0 2 9 3 5 7 7 6 4 3 2 6 
9 5 3 4 1 1 9 5 2 9 7 4 1 1 8 4 3 3 7 3 8 0 8 8 3 5 5 2 8 2 
3 7 7 6 2 7 3 2 5 7 9 1 4 5 8 3 5 1 5 0 8 9 9 6 5 5 0 2 9 2 
6 5 8 7 6 2 9 0 7 5 4 0 8 4 4 8 2 6 2 7 4 6 4 4 5 6 3 7 2 0 
9 1 4 5 2 0 3 1 5 4 0 3 9 4 3 2 5 8 1 1 8 3 9 5 4 6 2 0 3 7 
3 1 4 1 6 3 7 0 4 3 7 9 3 2 9 5 0 3 9 5 3 2 7 7 0 6 5 8 9 7 
0 1 3 7 2 1 3 8 8 8 8 9 3 4 7 3 6 2 2 5 4 4 1 3 8 3 9 4 1 0 
aoa:
6 5 5 2 1 7 9 6 6 6 8 9 0 3 5 2 8 7 6 2 3 9 7 4 0 6 0 3 0 1 
5 7 5 9 7 5 5 7 4 0 8 8 4 1 9 0 8 2 6 9 0 8 1 2 2 6 0 1 9 9 
9 7 1 5 7 6 3 5 3 4 1 9 9 8 5 9 3 5 1 5 8 8 0 0 4 4 6 1 5 6 
1 8 7 1 5 7 3 8 1 9 4 3 8 0 8 8 7 6 3 3 9 5 0 9 6 2 4 7 4 1 
8 3 8 2 0 1 0 5 6 6 5 6 8 7 4 6 9 0 1 1 0 4 3 1 6 3 8 5 6 0 
4 2 7 6 8 2 2 9 0 7 1 2 5 9 4 1 7 8 0 8 4 9 1 4 2 0 5 9 2 3 
0 0 1 6 5 4 9 6 5 2 4 5 7 3 4 9 2 6 1 8 9 8 8 8 8 3 8 4 6 9 
6 7 0 3 7 2 5 6 8 9 0 1 4 7 8 2 7 3 2 3 1 8 1 4 2 7 9 4 9 5 
0 1 9 8 5 4 0 0 9 2 2 7 1 9 5 7 4 6 7 8 8 6 6 4 2 9 0 0 0 3 
7 6 5 0 9 9 4 1 3 8 6 4 7 0 7 9 8 3 8 7 3 8 4 9 9 8 8 3 1 8 
9 9 3 4 7 2 0 1 5 7 1 1 1 0 0 5 6 2 9 4 0 1 2 9 5 4 3 9 4 1 
0 0 5 9 1 4 5 4 8 8 2 2 0 4 3 3 4 3 7 5 9 2 7 5 1 3 8 1 8 6 
5 8 4 1 5 3 1 0 3 6 9 0 6 7 1 0 5 8 2 6 1 4 7 0 2 0 7 0 4 2 
4 5 4 3 6 8 2 3 8 4 2 5 7 7 6 8 3 3 9 6 0 8 8 6 5 1 9 0 4 9 
8 3 4 9 7 3 1 2 5 9 4 1 7 1 3 3 1 5 5 2 1 2 1 5 8 9 7 6 7 7 
2 6 0 1 6 0 3 6 0 5 9 0 0 3 8 1 5 5 0 3 2 0 7 6 1 9 8 8 0 7 
6 2 7 9 6 7 5 8 5 5 8 8 3 7 2 5 5 3 7 1 4 4 9 7 1 2 6 0 2 7 
3 6 4 3 2 7 8 0 6 1 2 1 7 3 2 6 7 9 4 5 1 8 6 6 0 4 4 6 9 5 
1 0 9 3 5 5 3 8 5 3 6 3 6 8 0 1 0 0 4 4 4 9 4 8 6 9 3 6 5 1 
2 9 8 2 7 6 7 2 7 5 7 8 3 4 3 8 0 9 0 4 0 2 0 3 0 3 7 1 0 0 
1 0 7 1 3 9 8 6 2 0 0 3 9 9 1 4 0 5 5 1 4 7 7 3 2 4 9 3 3 9 
4 9 9 5 3 0 2 2 0 0 1 9 6 1 5 9 8 7 5 7 1 6 6 4 6 2 4 0 6 4 
7 4 2 7 5 8 5 2 5 9 6 1 5 2 9 6 2 6 3 6 0 8 1 9 3 0 2 1 7 1 
3 5 0 2 4 5 2 2 9 3 1 2 9 4 0 4 7 0 2 6 0 5 8 1 0 0 1 0 9 0 
3 4 6 3 9 0 4 6 5 1 7 1 9 3 7 9 1 8 9 8 4 0 6 2 8 0 9 6 5 8 
6 8 2 6 9 0 7 3 1 8 4 6 3 4 7 3 0 4 7 7 9 3 4 4 5 6 6 6 9 9 
5 3 6 3 0 6 3 8 6 2 0 6 5 9 6 3 3 2 4 0 9 5 6 2 1 1 7 1 1 8 
0 3 8 8 2 6 6 0 7 2 0 3 0 3 4 4 3 1 3 5 1 3 7 4 9 7 1 1 7 6 
9 0 1 8 4 4 7 7 5 0 2 9 0 7 9 2 8 5 6 6 0 0 4 3 1 7 7 8 0 8 
3 0 6 3 2 5 3 2 5 0 6 3 7 3 1 9 4 0 9 7 6 9 2 1 1 8 2 5 0 1
</pre>
</div>
</div>


<div id="outline-container-org952a85a" class="outline-4">
<h4 id="org952a85a"><span class="section-number-4">1.7.11</span> Malloc array of arrays structs?</h4>
<div class="outline-text-4" id="text-1-7-11">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACES</span> 13
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACEOFF</span> 1

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NSUIT</span> 4

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">PlayingCard</span> <span style="color: #0000ff;">randomCard</span>() {
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">card</span> = {ACE, CLUBS};
    card.face = NFACEOFF + ( rand() % NFACES );
    card.suit =  rand() % NSUIT;
    <span style="color: #a020f0;">return</span> card;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">HANDS</span> = 1000000;
    <span style="color: #228b22;">PlayingCard</span> * <span style="color: #a0522d;">hands</span> = malloc(<span style="color: #a020f0;">sizeof</span>(PlayingCard)*HANDS*HANDSIZE);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS*HANDSIZE; i++) {
        hands[i] = randomCard();
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flushes</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #a020f0;">if</span> (isFlush(hands + i*HANDSIZE)) {
            <span style="color: #a020f0;">if</span> (flushes &lt; 10) { <span style="color: #b22222;">// </span><span style="color: #b22222;">reduce printing</span>
                printf(<span style="color: #8b2252;">"Flush found at card %d\n"</span>, i);
                printf(<span style="color: #8b2252;">"Suit %d\n"</span>, hands[i].suit);
            }
            flushes++;
        }
    }
    printf(<span style="color: #8b2252;">"We found %d flushes out of %d hands: %f\n"</span>, flushes, HANDS, flushes/(<span style="color: #228b22;">float</span>)(HANDS));
}


</pre>
</div>

<pre class="example">
Flush found at card 141
Suit 0
Flush found at card 247
Suit 1
Flush found at card 502
Suit 1
Flush found at card 902
Suit 3
Flush found at card 1013
Suit 3
Flush found at card 1113
Suit 3
Flush found at card 1162
Suit 1
Flush found at card 1180
Suit 1
Flush found at card 1296
Suit 2
Flush found at card 1553
Suit 3
We found 3975 flushes out of 1000000 hands: 0.003975
</pre>

<p>
That's kind of gross, let's model our hands as arrays of 5 cards instead.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACES</span> 13
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACEOFF</span> 1

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NSUIT</span> 4

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">PlayingCard</span> <span style="color: #0000ff;">randomCard</span>() {
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">card</span> = {ACE, CLUBS};
    card.face = NFACEOFF + ( rand() % NFACES );
    card.suit =  rand() % NSUIT;
    <span style="color: #a020f0;">return</span> card;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">HANDS</span> = 1000000;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Pointer to arrays</span>
    <span style="color: #228b22;">PlayingCard</span> (*<span style="color: #a0522d;">hands</span>)[5] = malloc(<span style="color: #a020f0;">sizeof</span>(PlayingCard[5])*HANDS);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 0; j &lt; HANDSIZE; j++) {
            hands[i][j] = randomCard();
        }
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flushes</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #a020f0;">if</span> (isFlush(hands[i])) {
            <span style="color: #a020f0;">if</span> (flushes &lt; 10) { <span style="color: #b22222;">// </span><span style="color: #b22222;">reduce printing</span>
                printf(<span style="color: #8b2252;">"Flush found at card %d\n"</span>, i);
                printf(<span style="color: #8b2252;">"Suit %d\n"</span>, hands[i][0].suit);
            }
            flushes++;
        }
    }
    printf(<span style="color: #8b2252;">"We found %d flushes out of %d hands: %f\n"</span>, flushes, HANDS, flushes/(<span style="color: #228b22;">float</span>)(HANDS));
}


</pre>
</div>

<pre class="example">
Flush found at card 22
Suit 0
Flush found at card 456
Suit 1
Flush found at card 641
Suit 1
Flush found at card 668
Suit 3
Flush found at card 709
Suit 0
Flush found at card 999
Suit 2
Flush found at card 1243
Suit 3
Flush found at card 1261
Suit 3
Flush found at card 1322
Suit 3
Flush found at card 1417
Suit 2
We found 3994 flushes out of 1000000 hands: 0.003994
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abram Hindle</p>
<p class="date">Created: 2020-02-27 Thu 11:34</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
